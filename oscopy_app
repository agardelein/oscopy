#!/usr/bin/python
"""
Sample command line application
"""
import re
import readline
import os.path
from optparse import OptionParser
import oscopy
from oscopy.readers.reader import ReadError

class OscopyApp(object):
    """ Analyse command arguments and call function from Cmd
    See Cmd for more help
    """
    def __init__(self):
        self.cmds = oscopy.Context()
        # Prompt
        p = "oscopy> "
        # History file
        self.hist_file = ".oscopy_hist"

        # Readline configuration
        if not os.path.exists(self.hist_file):
            f = open(self.hist_file, "w")
            f.write("figlist")
            f.close()
        readline.read_history_file(self.hist_file)

        # Parse command line arguments
        # Current options:
        #   -b : batch mode, read commands from file
        #   -i : interactive mode, do not quit at the end of batch file
        #   -q : do not display startup message
        parser = OptionParser()
        parser.add_option("-b", "--batch", dest="fn", help="Execute commands in FILE then exit", metavar="FILE")
        parser.add_option("-i", "--interactive", action="store_true", dest="inter", help="Go to interactive mode after executing batch file")
        parser.add_option("-q", "--quiet", action="store_true", dest="quiet", help="Do not display startup message")
        (options, args) = parser.parse_args()
        if options.fn is None:
            f = None
        else:
            try:
                f = open(options.fn, 'r')
            except IOError, e:
                print "Unable to access batch file:", e
                f = None
        if options.inter == True:
            batch = False
        else:
            batch = True

        # Startup message
        if options.quiet is None:
            print "This is oscopy, a program to view electrical simulation results\n\
Copyright (C) 2009 Arnaud Gardelein.\n\
This is free software, you are invited to redistribute it \n\
under certain conditions.\n\
There is ABSOLUTELY NO WARRANTY; not even for MERCHANTIBILITY or\n\
FITNESS FOR A PARTICULAR PURPOSE."

        # Current graph and current figure
        self._current_figure = None
        self._current_graph = None

        # Start main loop
        self.loop(p, f, batch)

    def create(self, args):
        if args == "help":
            print "Usage : create [SIG [, SIG [, SIG]...]]"
            print "   Create a new figure, set_ it as current, add the signals"
            return
        self.cmds.create(self.get_signames(args))
        self._current_figure = self.cmds.figs[len(self.cmds.figs) - 1]

    def destroy(self, args):
        if args == "help":
            print "Usage : destroy FIG#"
            print "   Destroy a figure"
            return        
        self.cmds.destroy(eval(args))
        # Go back to the first graph of the first figure or None
        if len(self.cmds.figs):
            self._current_figure = self.cmds.figs[0]
            if self._current_figure.grafs:
                self._current_graph = self._current_figure.graphs[0]
            else:
                self._current_graph = None
        else:
            self._current_figure = None
            self._current_graph = None

    def select(self, args):
        if args == "help":
            print "Usage: select FIG#-GRAPH#"
            print "   Select the current figure and the current graph"
            return
        s = args.split('-')
        num = eval(s[0])
        if len(s) > 1:
            gn = eval(s[1])
        else:
            print "Usage: select FIG#-GRAPH#"
            return
        self.cmds.current = num, gn
        self._current_figure = self.cmds.figs[num - 1]
        self._current_graph = self._current_figure.grafs[gn - 1]

    def layout(self, args):
        if args == "help":
            print "Usage : layout horiz|vert|quad"
            print "   Define the layout of the current figure"
            return
#        if self._current_figure is not None:
#            self._current_figure.layout = args
        self.cmds.layout = args

    def figlist(self, args):
        if args == "help":
            print "Usage : figlist"
            print "   Print the list of figures"
            return

        SEPARATOR = " "
        for f in self.cmds.figures:
            print "%s Figure %d: %s" % ([" ", "*"][f["current"]],\
                                            f["num"], f["layout"])
            for g in f["graphs"]:
                print "    %s Graph %d : (%s) %s"\
                    %([" ","*"][g["current"]],\
                          g["num"], g["type"],\
                          SEPARATOR.join(g["signals"]))

    def plot(self, args):
        if args == "help":
            print "Usage : plot"
            print "   Draw and show the figures"
            return
        try:
            self.cmds.plot()
            self.cmds.show()
        except OverflowError, e:
            print "OverflowError in plot:", e.message, ", log(0) somewhere ?"

    def read(self, args):
        if args == "help":
            print "Usage : load DATAFILE"
            print "   Load signal file"
            return
        fn = args
        try:
            self.cmds.read(fn)
        except ReadError, e:
            print "Failed to read %s:" % fn, e
            return
        except NotImplementedError:
            print "File format not supported"
            return

        print fn, ":"
        for signal in self.cmds.signals:
            if signal["reader"] == fn:
                print '%s / %s %s' % (signal['name'],\
                                          signal['reference'],\
                                          signal['unit'])

    def write(self, args):
        if args == "help":
            print "Usage: write format [(OPTIONS)] FILE SIG [, SIG [, SIG]...]"
            print "   Write signals to file"
            return
        # Extract format, options and signal list
        tmp = re.search(r'(?P<fmt>\w+)\s*(?P<opts>\([^\)]*\))?\s+(?P<fn>[\w\./]+)\s+(?P<sigs>\w+(\s*,\s*\w+)*)', args)

        if tmp is None:
            print "What format ? Where ? Which signals ?"
            return
        fmt = tmp.group('fmt')
        fn = tmp.group('fn')
        opt = tmp.group('opts')
        sns = self.get_signames(tmp.group('sigs'))
        opts = {}
        if opt is not None:
            for on in opt.strip('()').split(','):
                tmp = on.split(':', 1)
                if len(tmp) == 2:
                    opts[tmp[0]] = tmp[1]
        try:
            self.cmds.write(fn, fmt, sns, opts)
        except WriteError, e:
            print "Write error:", e
            return
        except NotImplementedError:
            print "File format not supported"
            return

    def update(self, args):
        if args == "help":
            print "Usage: update"
            print "   Reread data files"
            return
        self.cmds.update()

    def add(self, args):
        if args == "help":
            print "Usage : add SIG [, SIG [, SIG]...]"
            print "   Add a graph to the current figure"
            return
        self.cmds.add(self.get_signames(args))
        if self._current_figure:
            self._current_graph =\
                self._current_figure.grafs[len(self._current_figure.grafs) - 1]

    def delete(self, args):
        if args == "help":
            print "Usage : delete GRAPH#"
            print "   Delete a graph from the current figure"
            return
        self.cmds.delete(args)

    def mode(self, args):
        if args == "help":
            print "Usage: mode MODE"
            print "   Set the type of the current graph of the current figure"
            print "Available modes :\n\
   lin      Linear graph\n"
#   fft      Fast Fourier Transform (FFT) of signals\n\
#   ifft     Inverse FFT of signals"
            return
        self.cmds.mode = args

    def scale(self, args):
        if args == "help":
            print "Usage: scale [lin|logx|logy|loglog]"
            print "   Set the axis scale"
            return
        self.cmds.scale = args

    def range(self, args):
        if args == "help":
            print "Usage: range [x|y min max]|[xmin xmax ymin ymax]|[reset]"
            print "   Set the axis range of the current graph of the current figure"
            return
        range = args.split()
        if len(range) == 1:
            if range[0] == "reset":
                self.cmds.range = range[0]
        elif len(range) == 3:
            if range[0] == 'x' or range[0] == 'y':
                self.cmds.range = range[0], [float(range[1]), float(range[2])]
        elif len(range) == 4:
            self.cmds.range = [float(range[0]), float(range[1]), float(range[2]), float(range[3])]

    def unit(self, args):
        if args == "help":
            print "Usage: unit [XUNIT,] YUNIT"
            print "   Set the unit to be displayed on graph axis"
            return

        units = args.split(",", 1)
        if len(units) < 1:
            return
        elif len(units) == 1:
            self.cmds.unit = units[0].strip(),
        elif len(units) == 2:
            self.cmds.unit = units[0].strip(), units[1].strip()
        else:
            return

    def insert(self, args):
        if args == "help":
            print "Usage: insert SIG [, SIG [, SIG]...]"
            print "   Insert a list of signals into the current graph"
            return
        self.cmds.insert(self.get_signames(args))

    def remove(self, args):
        if args == "help":
            print "Usage: remove SIG [, SIG [, SIG]...]"
            print "   Delete a list of signals into from current graph"
            return
        self.cmds.remove(self.get_signames(args))

    def freeze(self, args):
        if args == "help":
            print "Usage: freeze SIG [, SIG [, SIG]...]"
            print "   Do not consider signal for subsequent updates"
        self.cmds.freeze(self.get_signames(args))

    def unfreeze(self, args):
        if args == "help":
            print "Usage: unfreeze SIG [, SIG [, SIG]...]"
            print "   Consider signal for subsequent updates"
        self.cmds.unfreeze(self.get_signames(args))

    def siglist(self, args):
        if args == "help":
            print "Usage : siglist"
            print "   List loaded signals"
            return
        SEPARATOR = "\t"
        HEADER=["Name", "Unit", "Ref", "Reader"]
        print SEPARATOR.join(HEADER)
        for signal in self.cmds.signals:
            print SEPARATOR.join((signal["name"], \
                                      signal["unit"],\
                                      signal["reference"],\
                                      signal["reader"]))

    def math(self, inp):
        if inp == "help":
            print "Usage: destsig=mathexpr"
            print "   Define a new signal destsig using mathematical expression"
            return
        try:
            self.cmds.math(inp)
        except ReadError, e:
            print "Error creating signal from math expression", e
            return

    def get_signames(self, args):
        """ Return the signal names list extracted from the commandline
        The list must be a coma separated list of signal names.
        If no signals are loaded of no signal are found, return []
        """
        sns = []
        if args == "":
            sns = []
        else:
            for sn in args.split(","):
                sns.append(sn.strip())
        return sns

    def help(self, args):
        """ Display help messages
        """
        if args == "":
            print "\
Commands related to figures:\n\
   create      create a new figure\n\
   destroy     delete a figure\n\
   select      define the current figure and the current graph\n\
   layout      set_ the layout (either horiz, vert or quad)\n\
   figlist     list the existing figures\n\
   plot        draw and show the figures\n\
Commands related to graphs:\n\
   add         add a graph to the current figure\n\
   delete      delete a graph from the current figure\n\
   mode        set_ the mode of the current graph of the current figure\n\
   unit        set_ the units of the current graph of the current figure\n\
   scale       set_ the scale of the current graph of the current figure\n\
   range       set_ the axis range of the current graph of the current figure\n\
Commands related to signals:\n\
   read        read signals from file\n\
   write       write signals to file\n\
   update      reread signals from file(s)\n\
   insert      add a signal to the current graph of the current figure\n\
   remove      delete a signal from the current graph of the current figure\n\
   (un)freeze  toggle signal update\n\
   siglist     list the signals\n\
Misc commands:\n\
   echo        print a message\n\
   pause       wait for the user to press enter\n\
   quit, exit  exit the program\n\
   help        display this help message\n\
\n\
During plot:\n\
   1, 2        Toggle first and second vertical cursors\n\
   3, 4        Toggle first and second horizontal cursors\n\
Maths:\n\
   SIG = EXPR  Compute a signal from mathematical expression\n\
   SIG = [i]fft(SIG)\n\
               Compute Fast Fourier Transform (FFT) or inverse FFT from SIG\n\
\n\
Help for individual command can be obtained with 'help COMMAND'\
"
        else:
            if args in dir(cmds):
                eval("self." + args + "(\"help\")")
            else:
                print "Unknown command", args

    def echo(self, args):
        if args == "help":
            print "Usage: echo [TEXT]"
            print "   Print text"
            return
        print args        

    def pause(self, args):
        if args == "help":
            print "Usage: pause"
            print "   Wait for the user to press enter"
            return
        inp = raw_input("Press enter")

    def loop(self, p, f = None, batch = False):
        # Main loop
        while True:
            try:
                if f is None:
                    inp = raw_input(p)
                else:
                    try:
                        inp = f.readline().rstrip("\n")
                        if inp == "":
                            if batch == True:
                                # Batch mode, exit at the end of script
                                break
                            else:
                                # Interactive mode, continue with command line
                                f = None
                                continue
                    except IOError, e:
                        print "Script error:", e
                        f.close()
                        f = None
                # Check if line is a comment
                if inp.lstrip().startswith("#"):
                    continue
                # Check if command is assignment
                if inp.find("=") >= 0:
                    self.math(inp)
                    continue

                # Separate command from args
                if inp.find(" ") >= 0:
                    st = inp.lstrip().split(' ', 1)    
                    cmd = st[0]
                    args = st[1]
                    # print "cmd:", cmd, "args:", args
                else:
                    cmd = inp
                    args = ""
            
                # End of program
                if cmd == "exit" or cmd == "quit":
                    break

                # Evaluate the command
                if cmd in dir(self):
                    eval("self." + cmd + "(args)")
                else:
                    print cmd, "not supported"
                    continue
    
            except EOFError:
                break

            #    except AttributeError, e:
            #        print "Unknown command:", e.message
            #        continue
            
            #    except NameError, e:
            #        print "Unknown command", e.message
            #        continue

            except SyntaxError, e:
                print "Syntax Error", e.message
                continue
            
            except ReadError, e:
                print "Error in read :", e

        readline.write_history_file(self.hist_file)

if __name__ == "__main__":
    o = OscopyApp()


