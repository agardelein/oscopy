\documentclass[a4paper,11pt]{article}

\usepackage[english]{babel}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{wasysym}

\newcommand{\att}[1]{\texttt{#1}}
\newcommand{\meth}[1]{\texttt{#1()}}

\newcommand{\sig}{\textsf{Signal}}
\newcommand{\rds}{\textsf{Reader}}
\newcommand{\rdserr}{\textsf{ReadError}}
\newcommand{\module}[1]{\textsc{#1}}

\title{{\sc Oscopy}\\An interactive program for viewing electrical simulation results\\Manual}
\author{Arnaud Gardelein}

\begin{document}

\maketitle
\begin{abstract}
This is oscopy, a kind of oscilloscope in python, to view 2D electrical
simulation or measurement results.
It is designed to easily add new data file formats and new types of plots.

This document covers all important concepts and classes, and explain interactions between them.
\end{abstract}

\section{Introduction}
\label{sec:intro}
% >       * create a central design document that lists all important
% >         concepts/classes (Signal, Figure, ...) and explains interactions
% >         between them; this would really help a lot
% This one is more important. When we figure out and specify how various
% object interact between themselves, we're practically done. Then all the
% code just follows naturally.
In the electrical system design workflow, viewing results from analog simulation or experi\-ment is not a trivial task: there exist numerous different program with even more different file formats, the user interface has to be friendly and functional, and the program should be memory efficient due to the number of data points per file that can quickly grow.

The gEDA suite contains mainly all tools required to design electrical boards, from scheme drawings to PCB routing.
There already exist several programs to view analog simulation results: gwave, GSpiceUI, dataplot.

Gwave is designed as a waveform viewer, an can read text file as well as binary file generated by Spice2, Spice3, ngspice, CAzM or gnucap.
The user interface present features such as drag and drop signal into the graphs, vertical bar cursors, support for multiple files and multiples panels.

GSpiceUI is more focused on the user interaction between the user and the simulation program: it import the schematic from gschem, allow the user to build the file to be used by the simulation and plot the results, eventually using GWave.

Dataplot has support for format like gnucap, ngspice, hdf5 and touchstone.
The user interface has a tabs for multiple plots, and present the data in a hierarchical manner.

Another way of viewing results is to use Octave (and generally gnuplot).
This approach permit to post-process the results with operation such as FFT, diff.
Support for multiple figures is present.
Octave support HDF5 file format and tab-separated text-based files such as gnucap output.
The user interaction is essentially based on command line interface.

The idea behind Oscopy is to combine the better of those approaches into a single program easily extendable.
In this purpose, it present features like multiple plots, multiple windows, different plot types (linear, log) and allow the user to do math with data, including basic operations, trigonometry, fft, diff.
It support the gnucap file format for input and output, and has an update mechanism to reread data from files.
New file formats and new graph types can be added by following the guidelines presented in this document.

\section{Oscopy}
\label{sec:itf}
Oscopy is designed to be an interface between the user and the results that comes as well from simulation as experiment (Figure~\ref{fig:itf}).
Thus the program interacts with two entities:
\begin{enumerate}
\item the user
\item the data
\end{enumerate}
The results are considered to be a list of point representing an electrical signal property (amplitude, intensity, power...).
In the following, results, data and signals appellations are used indifferently.

\begin{figure}[htbp]
  \centering
  \includegraphics{../pdf/itf}
  \caption{Oscopy is designed to be an interface between the electrical simulation (or experimental) results and the user.}
  \label{fig:itf}
\end{figure}

\subsection{User interaction}
\label{sec:user}
In a standard session, the user configure the way of viewing data, examine the results, do some adjustments such as add more data, do some post-processing...
There are then two modes of the program:
\begin{enumerate}
\item Data viewing configuration
\item Result examination
\end{enumerate}
Those two modes are non-exclusive and can be executed either consecutively or simultaneously.

The data viewing configuration mode gather all operations such as:
\begin{itemize}
\item interaction with the filesystem (read, write, update data from files)
\item post-process data, mainly do math operations
\item manipulate data to be displayed (e.g. add, remove data)
\end{itemize}
Results examination mode contains operations:
\begin{itemize}
\item zoom, pan views
\item manipulate cursors
\end{itemize}

\subsection{Data interaction}
\label{sec:data}
%The relationship between the data and Oscopy:
% read files
% write files
% graph operations

\subsubsection{Interaction with files}
\label{sec:fileinter}
Oscopy can import and export signals to files.
This is done through the use of Reader-derived objects for import and Writer-derived objects for export.
Reader parse the file and create as many \sig\ as needed, and transmit a dict of \sig s to Oscopy.

For export, Oscopy transmit a dict of \sig s to the Writer object, which write the data to the file in the desired format.

For more details, see Reader and Writer sections.

\begin{figure}[htbp]
  \centering
  \includegraphics{../pdf/fileinter}
  \caption{Oscopy get the data (or \sig s) from files through Reader objects, and put data into files through Writer objects. Each Reader/Writer support a specific file format.}
  \label{fig:fileinter}
\end{figure}

\subsubsection{Viewer interaction}
\label{sec:viewinter}
The signals are presented to the user through a viewer program, currently matplotlib.
The interaction between Oscopy and the viewer is handled by Figure and Graph objects.

\begin{figure}[htbp]
  \centering
  \includegraphics{../pdf/viewinter}
  \caption{Interaction  of Oscopy with the viewer. Oscopy communicate with Figures, which contains up to 4 Graphs. The Graphs contains the \sig s.}
  \label{fig:viewinter}
\end{figure}

\section{Signals}
\label{sec:sigs}

A \sig\ is an object that basically contain the data points.
For example this could be the Y axis data of a temporal measurement.

Since generally in a simulation or experimental results many signal share the same scale, e.g. time scale or frequency scale, the \sig\ is associated to a reference signal.
To make the difference between a ``\sig'' and a ``reference \sig'', the latter has its \att{ref}\ attribute set to \att{None}.

We humans give to each signal a name, e.g. V1, Iout... and associate a unit (Volts, Watts...).
The \sig\ thus possess those two attributes.

And finally, when rereading the data from file, one want not always update each Signal, for instance to compare two simulations with different component values.
When the attribute \att{frozen} is set, the \sig\ is not updated.
For now this attribute is not accessed as a property but through the method freeze().
\begin{table}[htbp]
  \centering\small\sf
  \begin{tabular}{lcccl}
    \hline
    Attribute & Type & Read & Write & Comment \\
    \hline
    data     & numpy.array & \checked & \checked & Data points\\
    name     & string & \checked &          & Name of the signal \\
    ref      & \sig\ & \checked & \checked & Reference signal \\
    unit     & string & \checked &          & Unit of the data \\
    frozen   & bool   & \checked & \checked & Update signal or not\\
    \hline
  \end{tabular}
  \caption{Properties of \sig s.}
  \label{tab:sigs:props}
\end{table}

\section{Readers}
\label{sec:readers}
The module \module{Readers}\ is used to load signals, mainly from files.
It composed of a main class \rds, an exception class \rdserr.
Each file format is supported through a specific back-end.
The back-end class is created by deriving the base class \rds\ and redefining only the way to 1) check if the file is supported and 2) load the signals from the file.
The function \meth{DectectReader}\ should be used to automagically find the right back-end from the file name.
The interaction between objects is summarised in Figure~\ref{fig:rds:callgraph}.

\begin{figure}[htbp]
  \centering
  \includegraphics{../pdf/readers}
  \caption{Call graph of Readers module. \meth{DetectReader} create the object for the user. The only visible functions to the user are \meth{read} and \meth{update}. The dashed method should be redefined when deriving \rds\ to support new file formats.}
  \label{fig:rds:callgraph}
\end{figure}

\subsection{Reader}
\label{sec:readers:reader}
 
A \rds\ is used to load the data from a file.
The \rds\ class provide the tools to ensure the file is readable and the update mechanism to make the new back-end definition easier.
The table~\ref{tab:rds:meth} show the methods of this class.

The main method of this object is then \meth{read}, which is user-visible.
However, this is \meth{read\_sigs}\ that does the real work, i.e. parse the file and create the signals.
The file format support is verified by \meth{detect}.
Those two methods should be redefined when deriving \rds.

The file access is verified by \meth{check}, and the update mechanism is handled through \meth{update}.

\begin{table}[htbp]
  \centering\sf\small
  \begin{tabular}{lll}
    \hline
    Method & Type & Action \\
    \hline
    \_\_init\_\_ & Public & Initialise the object \\
    \_\_str\_\_  & Public & Return a string with the filename\\
    read         & Public & Read the data\\
    update       & Public & Reread the data\\
    detect       & Public & Return True if file is handled\\
    check        & Private& Raise an exception if the file is not readable\\
    read\_sigs    & Private& Read the data \\
    \hline
  \end{tabular}
  \caption{Methods of \rds}
  \label{tab:rds:meth}
\end{table}

\subsection{DetectReader}
\label{sec:readers:detect}
This function find the right back-end to read the file and return a valid \rds.
It call the method \meth{detect} of each known \rds-based object until a True is returned, meaning the object can handle the file.

\subsection{ReadError}
\label{sec:readers:readerror}
This exception class is raised whenever an error is encountered during the file access, e.g. no file, bad file type...
It contains only the constructor and a str method that returns the error message \att{value}.

\subsection{Adding new Readers}
\label{sec:readers:add}
New back-end can be created to support new file formats, this is done by deriving the \rds\ object.
This object provide the necessary framework so that the derived class should only redefine two methods:
\begin{itemize}
\item \meth{detect} that returns True if the file format is supported
\item \meth{read\_sigs} that effectively parse the file and return a dict of signals
\end{itemize}
Boring tasks like file access check or update management are handled by \rds.
Note that the constructor should also call the base class one.

\section{Writers}
\label{sec:writers}
% + DetectWriter

\section{Graphs}
\label{sec:graphs}

\section{Figures}
\label{sec:figs}

\section{Cursors}
\label{sec:curs}

\section{Extending Oscopy}
\label{sec:ext}



\end{document}

%%% Local Variables: 
%%% Local IspellDict: british
%%% mode: latex
%%% TeX-master: t
%%% End: 
