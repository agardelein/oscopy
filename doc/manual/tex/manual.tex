\documentclass[a4paper,11pt]{article}

\usepackage[english]{babel}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{wasysym}
\usepackage[font=small,labelfont=sf,textfont=sf]{caption}

\newcommand{\att}[1]{\texttt{#1}}
\newcommand{\meth}[1]{\texttt{#1()}}
\newcommand{\cls}[1]{\textsf{#1}}

\newcommand{\ctx}{\cls{Context}}
\newcommand{\sig}{\cls{Signal}}
\newcommand{\rd}{\cls{Reader}}
\newcommand{\rderr}{\cls{ReadError}}
\newcommand{\wrt}{\cls{Writer}}
\newcommand{\wrterr}{\cls{WriteError}}
\newcommand{\module}[1]{\textsc{#1}}
\newcommand{\graph}{\cls{Graph}}
\newcommand{\fig}{\cls{Figure}}
\newcommand{\cursor}{\cls{Cursor}}
\title{{\sc Oscopy}\\An interactive program for viewing electrical simulation results\\Manual}
\author{Arnaud Gardelein}

\begin{document}

\maketitle
\begin{abstract}
This is oscopy, a kind of oscilloscope in python, to view 2D electrical
simulation or measurement results.
It is designed to easily add new data file formats and new types of plots.

This document covers all important concepts and classes, and explain interactions between them.
\end{abstract}

\section{Introduction}
\label{sec:intro}
% >       * create a central design document that lists all important
% >         concepts/classes (Signal, Figure, ...) and explains interactions
% >         between them; this would really help a lot
% This one is more important. When we figure out and specify how various
% object interact between themselves, we're practically done. Then all the
% code just follows naturally.
In the electrical system design workflow, viewing results from analog simulation or experi\-ment is not a trivial task: there exist numerous different program with even more different file formats, the user interface has to be friendly and functional, and the program should be memory efficient due to the number of data points per file that can quickly grow.

The gEDA suite contains mainly all tools required to design electrical boards, from scheme drawings to PCB routing.
There already exist several programs to view analog simulation results: gwave, GSpiceUI, dataplot.

Gwave is designed as a waveform viewer, an can read text file as well as binary file generated by Spice2, Spice3, ngspice, CAzM or gnucap.
The user interface present features such as drag and drop signal into the graphs, vertical bar cursors, support for multiple files and multiples panels.

GSpiceUI is more focused on the user interaction between the user and the simulation program: it import the schematic from gschem, allow the user to build the file to be used by the simulation and plot the results, eventually using GWave.

Dataplot has support for format like gnucap, ngspice, hdf5 and touchstone.
The user interface has a tabs for multiple plots, and present the data in a hierarchical manner.

Another way of viewing results is to use Octave (and generally gnuplot).
This approach permit to post-process the results with operation such as FFT, diff.
Support for multiple figures is present.
Octave support HDF5 file format and tab-separated text-based files such as gnucap output.
The user interaction is essentially based on command line interface.

The idea behind Oscopy is to combine the better of those approaches into a single program easily extendable.
In this purpose, it present features like multiple plots, multiple windows, different plot types (linear, log) and allow the user to do math with data, including basic operations, trigonometry, fft, diff.
It support the gnucap file format for input and output, and has an update mechanism to reread data from files.
New file formats and new graph types can be added by following the guidelines presented in this document.

\section{Oscopy}
\label{sec:itf}
Oscopy is designed to be an interface between the user and the results that comes as well from simulation as experiment (Figure~\ref{fig:itf}).
Thus the program interacts with two entities:
\begin{enumerate}
\item the user
\item the data
\end{enumerate}
The results are considered to be a list of point representing an electrical signal property (amplitude, intensity, power...).
In the following, results, data and signals appellations are used indifferently.

\begin{figure}[htbp]
  \centering
  \includegraphics{../pdf/itf}
  \caption{Oscopy is designed to be an interface between the electrical simulation (or experimental) results and the user.}
  \label{fig:itf}
\end{figure}

\subsection{User interaction}
\label{sec:user}
In a standard session, the user configure the way of viewing data, examine the results, do some adjustments such as add more data, do some post-processing...
There are then two modes of the program:
\begin{enumerate}
\item Data viewing configuration
\item Result examination
\end{enumerate}
Those two modes are non-exclusive and can be executed either consecutively or simultaneously.

The data viewing configuration mode gather all operations such as:
\begin{itemize}
\item interaction with the filesystem (read, write, update data from files)
\item post-process data, mainly do math operations
\item manipulate data to be displayed (e.g. add, remove data)
\end{itemize}
Results examination mode contains operations:
\begin{itemize}
\item zoom, pan views
\item manipulate cursors
\end{itemize}

\subsection{Data interaction}
\label{sec:data}
%The relationship between the data and Oscopy:
% read files
% write files
% graph operations

\subsubsection{Interaction with files}
\label{sec:fileinter}
Oscopy can import and export signals to files.
This is done through the use of Reader-derived objects for import and Writer-derived objects for export.
Reader parse the file and create as many \sig\ as needed, and transmit a dict of \sig s to Oscopy.

For export, Oscopy transmit a dict of \sig s to the Writer object, which write the data to the file in the desired format.

For more details, see Reader and Writer sections.

\begin{figure}[htbp]
  \centering
  \includegraphics{../pdf/fileinter}
  \caption{Oscopy get the data (or \sig s) from files through Reader objects, and put data into files through Writer objects. Each Reader/Writer support a specific file format.}
  \label{fig:fileinter}
\end{figure}

\subsubsection{Viewer interaction}
\label{sec:viewinter}
The results are presented to the user in a graphical manner, as a set of figures where the data is plotted.
On each figures, there can be several graphs containing each one containing a plot.
Each plot can hold as many signals as requested.
The interaction between Oscopy and the graphical representation is handled by \fig\ and \graph\ objects.
They both use \module{Matplotlib} to plot the data.

\begin{figure}[htbp]
  \centering
  \includegraphics{../pdf/viewinter}
  \caption{Interaction  of Oscopy with the viewer. Oscopy communicate with Figures, which contains up to 4 Graphs. The Graphs contains the \sig s.}
  \label{fig:viewinter}
\end{figure}

\subsection{Context}
The user and data interaction are gathered into the object \ctx, which handle the creation of readers, writers and figures objects.
It present an interface that can be split into a few parts:
\begin{itemize}
\item Data management
\item Figure management
\item Graph of current figure management
\item Pass-through to current graph of current figure
\end{itemize}
The methods of this interface are summarised in Table~\ref{tab:ctxt:meth}.

\begin{table}[htbp]
  \centering\sf\small
  \begin{tabular}{lll}
    \hline
    Method & Access & Action \\
    \hline
    \_\_init\_\_ & Public & Initialise the object \\
    \multicolumn{3}{l}{\textit{Data management}} \\
    read & Public & Load data from file\\
    write &Public & Save data to file \\
    update & Public & Reload data from files\\
    siglist & Public & Print the list of loaded signals\\
    freeze & Public & Disable update of some signals\\
    unfreeze & Public & Enable update of some signals\\
    math & Public & Create a signal from a math expression\\
    signames\_to\_sigs & Private\\
    \multicolumn{3}{l}{\textit{Figure management}} \\
    create & Public & Create a new figure\\
    destroy & Public & Destroy a figure \\
    figlist & Public & Print list of figures \\
    plot & Public & Draw the figures\\    
    select & Public & Select the current figure and graph \\
    \multicolumn{3}{l}{\textit{Graph management of current figure}} \\
    add & Public & Add a graph into the figure \\
    delete & Public & Delete a graph from the figure \\
    list & Public & Print a list of the graphs\\
    layout & Public & Define the placement of graph in the figure\\
    mode & Public & Define the mode of the current graph\\
    \multicolumn{3}{l}{\textit{Pass-through to current Graph of current figure}} \\
    insert & Public & Insert signals into the graph\\
    remove & Public & Take away signals from the graph\\
    range & Public & Define the limits of the graph\\
    scale & Public & Define the scale of the axis\\
    unit & Public & Define the unit to be displayed\\
    \hline
  \end{tabular}
  \caption{Methods of Context}
  \label{tab:ctxt:meth}
\end{table}

\section{Signals}
\label{sec:sigs}

A \sig\ is an object that basically contain the data points.
For example this could be the Y axis data of a temporal measurement.

Since generally in a simulation or experimental results many signal share the same scale, e.g. time scale or frequency scale, the \sig\ is associated to a reference signal.
To make the difference between a ``\sig'' and a ``reference \sig'', the latter has its \att{ref}\ attribute set to \att{None}.

We humans give to each signal a name, e.g. V1, Iout... and associate a unit (Volts, Watts...).
The \sig\ thus possess those two attributes.

And finally, when rereading the data from file, one want not always update each Signal, for instance to compare two simulations with different component values.
When the attribute \att{frozen} is set, the \sig\ is not updated.
For now this attribute is not accessed as a property but through the method \meth{freeze}.
\begin{table}[htbp]
  \centering\small\sf
  \begin{tabular}{lcccl}
    \hline
    Attribute & Type & Read & Write & Comment \\
    \hline
    data     & numpy.array & \checked & \checked & Data points\\
    name     & string & \checked &          & Name of the signal \\
    ref      & \sig\ & \checked & \checked & Reference signal \\
    unit     & string & \checked &          & Unit of the data \\
    frozen   & bool   & \checked & \checked & Update signal or not\\
    \hline
  \end{tabular}
  \caption{Properties of \sig s.}
  \label{tab:sigs:props}
\end{table}

\section{Readers}
\label{sec:readers}
The module \module{Readers}\ is used to load signals, mainly from files.
It composed of a main class \rd, an exception class \rderr, the back-end classes and a function \meth{DetectReader}.
Each file format is supported through a specific back-end.
The back-end class is created by deriving the base class \rd\ and redefining only the way to 1) check if the file is supported and 2) load the signals from the file.
The function \meth{DectectReader}\ should be used to automagically find the right back-end from the file name.
The interaction between objects is summarised in Figure~\ref{fig:rds:callgraph}.

\begin{figure}[htbp]
  \centering
  \includegraphics{../pdf/readers}
  \caption{Call graph of Readers module. \meth{DetectReader} create the object for the user. The only visible functions to the user are \meth{read} and \meth{update}. The dashed method should be redefined when deriving \rd\ to support new file formats.}
  \label{fig:rds:callgraph}
\end{figure}

\subsection{Reader}
\label{sec:readers:reader}
 
A \rd\ is used to load the data from a file.
The \rd\ class provide the tools to ensure the file is readable and the update mechanism to make the new back-end definition easier.
The Table~\ref{tab:rds:meth} show the methods of this class.

The main method of this object is then \meth{read}, which is user-visible.
However, this is \meth{read\_signals}\ that does the real work, i.e. parse the file and create the signals.
The file format support is verified by \meth{detect}.
Those two methods should be redefined when deriving \rd.

The file access is verified by \meth{check}, and the update mechanism is handled through \meth{update}.

\begin{table}[htbp]
  \centering\sf\small
  \begin{tabular}{lll}
    \hline
    Method & Access & Action \\
    \hline
    \_\_init\_\_ & Public & Initialise the object \\
    \_\_str\_\_  & Public & Return a string with the filename\\
    read         & Public & Read the data\\
    update       & Public & Reread the data\\
    detect       & Public & Return True if file is handled\\
    check        & Private& Raise an exception if the file is not readable\\
    read\_signals    & Private& Read the data \\
    \hline
  \end{tabular}
  \caption{Methods of \rd}
  \label{tab:rds:meth}
\end{table}

\subsection{DetectReader}
\label{sec:readers:detect}
This function find the right back-end to read the file and return a valid \rd.
It call the method \meth{detect} of each known \rd-based object until a True is returned, meaning the object can handle the file.

\subsection{ReadError}
\label{sec:readers:readerror}
This exception class is raised whenever an error is encountered during the file access, e.g. no file, bad file type...
It contains only the constructor and a str method that returns the error message \att{value}.

\subsection{Adding new Readers}
\label{sec:readers:add}
New back-end can be created to support new file formats, this is done by deriving the \rd\ object.
This object provide the necessary framework so that the derived class should only redefine two methods:
\begin{itemize}
\item \meth{detect} that returns True if the file format is supported
\item \meth{read\_signals} that effectively parse the file and return a dict of signals
\end{itemize}
Boring tasks like file access check or update management are handled by \rd.
Note that the constructor should also call the base class one.

\section{Writers}
\label{sec:writers}
This module is used to save data into a file.
It is composed of a main class \wrt, an exception class \wrterr, the back-end classes and a function \meth{DetectWriter}.
Each format is supported through a specific back-end.
The back-end class is defined by deriving the base class \wrt\ and redefining 1) the format name, 2) the way to check the format is supported and 3) how to save the data to file.
The function \meth{DetectWriter} should be used to automagically find the right back-end from the format name.
The interaction between the objects is summarised in Figure~\ref{fig:wrts:callgraph}.

\begin{figure}[htbp]
  \centering
  \includegraphics{../pdf/writers}
  \caption{Call graph of Writers module. \meth{DetectWriter} create the object for the user. Only \meth{write} is visible to the user. The dashed method should be redefined when deriving \wrt\ to support new file formats.}
  \label{fig:wrts:callgraph}
\end{figure}
\subsection{Writer}
% back-end
The purpose of the \wrt\ is to save the data to a file.
The \wrt\ class provide the tools to make the definition of new export format easier.
The Table~\ref{tab:wrts:meth} shows the methods of this class.

Only the methods \meth{detect} and \meth{write} are user visible.
The real work is done by \meth{write\_signals} that format the data and put them into the file.
\meth{detect} is used to check whether the back-end class support the format.
For now this is only a comparison between the name provided by the user and the result of the call to \meth{get\_format\_name}.

Before calling \meth{write\_signals}, \meth{write} check the file access (with \meth{check}) and do a format specific verification by calling \meth{format\_check}.
For example, for text columns-based formats like CSV, this could be checking that all signals share the same reference.
This function should be redefined by the derived class.

\begin{table}[htbp]
  \centering\sf\small
  \begin{tabular}{lll}
    \hline
    Method & Access & Action \\
    \hline
    \_\_init\_\_ & Public & Initialise the object \\
    write        & Public & Write the data, user visible function\\
    detect       & Public & Return True if format is handled\\
    check        & Private& Raise an exception if the file is not writable\\
    write\_signals  & Private& Write the data, to be defined by the back-end\\
    get\_format\_name&Private& Return the name of the format\\
    format\_check   & Private& Format-specific checks\\
    \hline
  \end{tabular}
  \caption{Methods of \wrt}
  \label{tab:wrts:meth}
\end{table}

\subsection{DetectWriter}
This function find the right back-end to write the file and then return a valid \wrt.
It call the method \meth{detect} of each known \wrt\ until a True is returned, meaning the object can handle the file format.

\subsection{WriteError}
This exception class is raised when an error occurs during the file access, for example bad file permissions.
There is only a constructor and a str method which return the error message \att{value}.

\subsection{Adding new Writers}
New formats are supported by adding a back-end to the module, by deriving the \wrt\ class.
This class provide the requested framework (file access checking, detection mechanism) to make the new format adding simpler.
Thus the new class should redefine the methods:
\begin{itemize}
\item \meth{get\_format\_name} that return a string identifying the format
\item \meth{format\_check} that verifies if signals are compliant with the format
\item \meth{write\_signals} that effectively write the data to the file
\end{itemize}
Note that the constructor of the new class should call the base class one.

The user can pass options to the back-end through the use of a dict, which is then available as \att{self.opts}.
For example, the option "ow" is supported by the base class.
When set to "1", the destination file can be overwritten.

\section{Figures}
\label{sec:figs}
A \fig\ is a container that manage \graph s, i.e. handle adding, deleting, formating and updating, as shown in Table~\ref{tab:figs:meth}.
It handle the layout and the mode of the graphs, and pass all data-plotting specific commands to the \graph s, through the use of an alias to the current graph \att{curgraph}.

When updating, for each graph it prepare a list of signals to be updated and deleted and then pass it to the graph.

When \meth{plot}\ is called, it set up the figure, the layout, and then call the method \meth{plot}\ of each graph.
Finally it set the method \meth{key}\ as a call-back for key-press related event in Matplotlib.
Currently this method handle the keys '1', '2', '3' and '4' to toggle cursors, as summarised in Table~\ref{tab:figs:key}.
It then call \meth{toggle\_cursors}\ from \graph.

\begin{table}[htbp]
  \centering\sf\small
  \begin{tabular}{lll}
    \hline
    Method & Access & Action \\
    \hline
    \_\_init\_\_ & Public & Initialise the object \\
    plot & Public & Draw the graphs\\
    \multicolumn{3}{l}{\textit{Graph management}} \\
    add & Public & Add a graph into the figure \\
    delete & Public & Delete a graph from the figure \\
    list & Public & Print a list of the graphs\\
    select & Public & Select the current graph \\
    set\_mode & Public & Define the mode of the current graph\\
    \multicolumn{3}{l}{\textit{Pass-through to current Graph}} \\
    insert & Public & Insert signals into the graph\\
    remove & Public & Take away signals from the graph\\
    \multicolumn{3}{l}{\textit{Viewing management}} \\
    key & Private & Handle keystrokes when displaying plots \\
    \multicolumn{3}{l}{\textit{Data management}} \\
    update & Public & Update signal list of all graphs\\
    \hline
  \end{tabular}
  \caption{Methods of \fig}
  \label{tab:figs:meth}
\end{table}
\begin{table}[htbp]
  \centering\small\sf
  \begin{tabular}{llll}
    \hline
    Property & Access & Type & Summary \\
    \hline
    \multicolumn{4}{l}{\textit{Graph management}}\\
    layout & Public & str & Disposition of graphs in the figure\\
    \multicolumn{4}{l}{\textit{Data management}}\\
    signals & Public & iter & Signals contained in the figure \\
    \multicolumn{4}{l}{\textit{Pass-through to current graph}}\\
    unit & Public & Tuple of str & The unit to be displayed in x/y labels\\
    scale & Public & str & Scale of the axis (one of lin,logx,logy,loglog) \\
    range & Public & list[4] & Axis limits \\
    \hline
  \end{tabular}
  \caption{Properties of \fig.}
  \label{tab:figs:props}
\end{table}

\begin{table}[htbp]
  \centering\small\sf
  \begin{tabular}{ll}
    \hline
    Key & Action \\
    \hline
    1  & Toggle first vertical cursor \\
    2  & Toggle second vertical cursor \\
    3  & Toggle first horizontal cursor \\
    4  & Toggle second horizontal cursor \\
    \hline
  \end{tabular}
  \caption{Keystrokes handled by \meth{key} in \fig.}
  \label{tab:figs:key}
\end{table}

\section{Graphs}
\label{sec:graphs}
The \module{Graphs} module is in charge to plot the data on one figure.
Since there are many ways of plotting data like linear graphs or smith charts, the module is composed of one base class \graph\ that handle the signal dict and the basic plotting.
This class is then derived, and the new ones generally redefine the way of plotting the data.

Additionally the user want a way to put references on the displayed data, thus the module contains a \cursor\ class to handle this.

\subsection{Graph}
\label{sec:graphs:graph}
A \graph\ is an object that present the data to the user.
It has mainly three types of methods:
\begin{description}
\item[data management] that e.g. insert or remove data from the \graph
\item[presentation management] that handle the viewing specific work e.g. the zoom area
\item[cursors management] that handle cursors related work e.g. toggling, displaying
\end{description}
The method \meth{get\_type} that identify the type of the graph, \meth{get\_type} do not fit in the previous categories.
The Table~\ref{tab:graphs:meth} summarise the methods of the \graph\ object, and Table~\ref{tab:graphs:props} the properties.
\begin{table}[htbp]
  \centering\sf\small
  \begin{tabular}{lll}
    \hline
    Method & Access & Action \\
    \hline
    \_\_init\_\_ & Public & Initialise the object \\
    find\_scale\_factor & Private & Find a human-readable multiplier to the data \\
    \multicolumn{3}{l}{\textit{Data management}} \\
    insert & Public & Insert signals into the graph\\
    remove & Public & Take away signals from the graph\\
    get\_signals & Public & Iterator that return the internal signal list\\
    \multicolumn{3}{l}{\textit{Viewing management}} \\
    plot & Public & Display the graph\\
    \multicolumn{3}{l}{\textit{Cursors management}} \\
    toggle\_cursor & Public & Change cursor status \\
    draw\_cursors & Private & Display the cursors on the graph\\
    set\_cursors & Private & Set the properties of a cursor\\
    print\_cursors & Private & Display the numerical values of the cursors\\
    \hline
  \end{tabular}
  \caption{Methods of \graph}
  \label{tab:graphs:meth}
\end{table}
\begin{table}[htbp]
  \centering\small\sf
  \begin{tabular}{llll}
    \hline
    Property & Access & Type & Summary \\
    \hline
    type & Public & str & Graph identification\\
    unit & Public & Tuple of str & The unit to be displayed in x/y labels\\
    scale & Public & str & Scale of the axis (one of lin,logx,logy,loglog) \\
    range & Public & list[4] & Axis limits \\
    signals & Public & iter & Signals contained in the graph\\
    \hline
  \end{tabular}
  \caption{Properties of \graph.}
  \label{tab:graphs:props}
\end{table}
\subsubsection{Data management methods}
The data is inserted into the graph with \meth{insert}, and removed with \meth{remove}.
It can be parsed by calling the generator \meth{get\_signals}.

\subsubsection{Viewing management}
The central function of this object is \meth{plot}, that does the work to present the data to the user.
A set of method is present to customise the range, scale type and units.
The range is the zoom area, the scale type is either linear or logarithmic, and the units are a string displayed along the axis.

\subsubsection{Cursors management}
From the external user perspective, cursors can only be toggled with \meth{toggle\_cursors}.
By default there are up to two cursors per axis to keep graph readable by a human.
Internally, \meth{toggle\_cursors} call \meth{set\_cursor} to define cursors properties, and \meth{plot} call \meth{draw\_cursors} and \meth{print\_cursors} to display respectively the cursors shape and value onto the graph.
The figure~\ref{fig:cursorinter} summarise this paragraph.

\begin{figure}[htbp]
  \centering
  \includegraphics{../pdf/cursorinter}
  \caption{Interaction between the user, \graph\ and \cursor.}
  \label{fig:cursorinter}
\end{figure}

\subsection{Cursors}
\label{sec:curs}
When annotating the graphs with Matplotlib, changes are lost when the figure window is closed.
Oscopy support cursors, i.e. a way to print references on a graph, through the use of annotation.
The goal of the \cursor\ object is to make the references persistent between figure close.

The tables~\ref{tab:cursors:meth} and \ref{tab:cursors:props} summarise the methods and attributes of this object.
Apart from the constructor and the string representation, it contains one method \meth{draw}, that handle the representation of the reference on the graph.

The main attribute is \att{value}, or the location on the graph of the reference.
The cursor can be \att{visible}, i.e. printed on the graph or not, and can be either horizontal or vertical, as defined by \att{type}.
The \att{line} object is a reference to the Matplotlib.Line2D where the cursor is drawn.

\begin{table}[htbp]
  \centering\sf\small
  \begin{tabular}{lll}
    \hline
    Method & Access & Action \\
    \hline
    \_\_init\_\_ & Public & Initialise the object \\
    draw & Public & Draw the cursor on the graph \\
    \_\_str\_\_ & Public & Print value, type and visible \\
    \hline
  \end{tabular}
  \caption{Methods of \cursor}
  \label{tab:cursors:meth}
\end{table}

\begin{table}[htbp]
  \centering\small\sf
  \begin{tabular}{lcccl}
    \hline
    Attribute & Type & Read & Write & Comment \\
    \hline
    value     & float & \checked & \checked & Position\\
    visible   & bool & \checked & \checked & State \\
    line      & matplotlib.Line2D & & & Where it is dawn \\
    type      & str & \checked & \checked & "horiz" or "vert"\\
    \hline
  \end{tabular}
  \caption{Properties of \cursor.}
  \label{tab:cursors:props}
\end{table}

\subsection{Adding new Graphs}
Adding new ways of plotting data is done by deriving \graph.
At least the method \meth{get\_type} should be redefined, and the constructor of the new class should call the base class one.
However, surely the method \meth{plot} has to be redefined to handle the new way of plotting data.

\subsection{Adding new Cursors}
By deriving \cursor, new way of putting references on the graph can be defined.
The method \meth{draw} then needs to be redefined.



\section{Extending Oscopy}
\label{sec:ext}



\end{document}

%%% Local Variables: 
%%% Local IspellDict: british
%%% mode: latex
%%% TeX-master: t
%%% End: 
