#!/usr/bin/python
import readline
import os.path
import sys
import re
from optparse import OptionParser

# Some variables
hist_file = ".oscopy_hist"
readers_dir = "Readers"

import Cmd
import Reader

class Oscopy:
    """ Analyse command arguments and call function from Cmd
    See Cmd for more help
    """
    def __init__(self):
        self.cmds = Cmd.Cmds()

    def create(self, args):
        if args == "help":
            print "Usage : create [SIG [, SIG [, SIG]...]]"
            print "   Create a new figure, set it as current, add the signals"
            return
        self.cmds.create(self.gettoplot(args))

    def destroy(self, args):
        if args == "help":
            print "Usage : delete FIG#"
            print "   Delete a figure"
            return        
        self.cmds.destroy(eval(args))

    def select(self, args):
        if args == "help":
            print "Usage: select FIG#[, GRAPH#]"
            print "   Select the current figure and the current graph"
            return
        s = args.split('-')
        num = eval(s[0])
        if len(s) > 1:
            gn = eval(s[1])
        else:
            gn = 0
        self.cmds.select(num, gn)

    def layout(self, args):
        if args == "help":
            print "Usage : layout horiz|vert|quad"
            print "   Define the layout of the current figure"
            return
        self.cmds.layout(args)

    def figlist(self, args):
        if args == "help":
            print "Usage : figlist"
            print "   Print the list of figures"
            return
        self.cmds.figlist()

    def plot(self, args):
        if args == "help":
            print "Usage : plot"
            print "   Draw and show the figures"
            return
        self.cmds.plot()

    def read(self, args):
        if args == "help":
            print "Usage : load DATAFILE"
            print "   Load signal file"
            return
        fn = args
        return self.cmds.read(fn)

    def write(self, args):
        if args == "help":
            print "Usage: write format [(OPTIONS)] FILE SIG [, SIG [, SIG]...]"
            print "   Write signals to file"
            return
        # Extract format, options and signal list
        tmp = re.search(r'(?P<fmt>\w+)\s*(?P<opts>\([^\)]*\))?\s+(?P<fn>[\w\.]+)\s+(?P<sigs>\w+(\s*,\s*\w+)*)', args)

        if tmp == None:
            print "What format ? Where ? Which signals ?"
            return
        fmt = tmp.group('fmt')
        fn = tmp.group('fn')
        opt = tmp.group('opts')
        sigs = self.gettoplot(tmp.group('sigs'))
        opts = {}
        if opt != None:
            for on in opt.strip('()').split(','):
                tmp = on.split(':', 1)
                if len(tmp) == 2:
                    opts[tmp[0]] = tmp[1]
        self.cmds.write(fn, fmt, sigs, opts)

    def update(self, args):
        if args == "help":
            print "Usage: update"
            print "   Reread data files"
            return
        self.cmds.update()

    def add(self, args):
        if args == "help":
            print "Usage : add SIG [, SIG [, SIG]...]"
            print "   Add a graph to the current figure"
            return
        self.cmds.add(self.gettoplot(args))

    def delete(self, args):
        if args == "help":
            print "Usage : delete GRAPH#"
            print "   Delete a graph from the current figure"
            return
        self.cmds.delete(args)

    def mode(self, args):
        if args == "help":
            print "Usage: mode MODE"
            print "   Set the type of the current graph of the current figure"
            print "Available modes :\n\
   lin      Linear graph\n\
   fft      Fast Fourier Transform (FFT) of signals\n\
   ifft     Inverse FFT of signals"
            return
        self.cmds.mode(args)

    def scale(self, args):
        if args == "help":
            print "Usage: scale [lin|logx|logy|loglog]"
            print "   Set the axis scale"
            return
        self.cmds.scale(args)

    def range(self, args):
        if args == "help":
            print "Usage: range [x|y min max]|[xmin xmax ymin ymax]|[reset]"
            print "   Set the axis range of the current graph of the current figure"
            return
        tmp = args.split()
        if len(tmp) == 1:
            if tmp[0] == "reset":
                self.cmds.range(tmp[0])
        elif len(tmp) == 3:
            if tmp[0] == 'x' or tmp[0] == 'y':
                self.cmds.range(tmp[0], float(tmp[1]), float(tmp[2]))
        elif len(tmp) == 4:
            self.cmds.range(float(tmp[0]), float(tmp[1]), float(tmp[2]), float(tmp[3]))

    def unit(self, args):
        if args == "help":
            print "Usage: unit [XUNIT,] YUNIT"
            print "   Set the unit to be displayed on graph axis"
            return

        us = args.split(",", 1)
        if len(us) < 1:
            return
        elif len(us) == 1:
            self.cmds.unit(us[0].strip())
        elif len(us) == 2:
            self.cmds.unit(us[0].strip(), us[1].strip())
        else:
            return

    def insert(self, args):
        if args == "help":
            print "Usage: insert SIG [, SIG [, SIG]...]"
            print "   Insert a list of signals into the current graph"
            return
        self.cmds.insert(self.gettoplot(args))

    def remove(self, args):
        if args == "help":
            print "Usage: remove SIG [, SIG [, SIG]...]"
            print "   Delete a list of signals into from current graph"
            return
        self.cmds.remove(self.gettoplot(args))

    def freeze(self, args):
        if args == "help":
            print "Usage: freeze SIG [, SIG [, SIG]...]"
            print "   Do not consider signal for subsequent updates"
        self.cmds.freeze(self.gettoplot(args))

    def unfreeze(self, args):
        if args == "help":
            print "Usage: unfreeze SIG [, SIG [, SIG]...]"
            print "   Consider signal for subsequent updates"
        self.cmds.unfreeze(self.gettoplot(args))

    def siglist(self, args):
        if args == "help":
            print "Usage : siglist"
            print "   List loaded signals"
            return
        self.cmds.siglist()

    def math(self, inp):
        if inp == "help":
            print "Usage: destsig=mathexpr"
            print "   Define a new signal destsig using mathematical expression"
            return
        self.cmds.math(inp)

    def gettoplot(self, args):
        sns = []
        if args == "":
            sns = []
        else:
            for sn in args.split(","):
                sns.append(sn.strip())
        return sns

    def help(self, args):
        """ Display help messages
        """
        if args == "":
            print "\
Commands related to figures:\n\
   create      create a new figure\n\
   destroy     delete a figure\n\
   select      define the current figure and the current graph\n\
   layout      set the layout (either horiz, vert or quad)\n\
   figlist     list the existing figures\n\
   plot        draw and show the figures\n\
Commands related to graphs:\n\
   add         add a graph to the current figure\n\
   delete      delete a graph from the current figure\n\
   mode        set the mode of the current graph of the current figure\n\
   unit        set the units of the current graph of the current figure\n\
   scale       set the scale of the current graph of the current figure\n\
   range       set the axis range of the current graph of the current figure\n\
Commands related to signals:\n\
   read        read signals from file\n\
   write       write signals to file\n\
   update      reread signals from file(s)\n\
   insert      add a signal to the current graph of the current figure\n\
   remove      delete a signal from the current graph of the current figure\n\
   (un)freeze  toggle signal update\n\
   siglist     list the signals\n\
Misc commands:\n\
   quit, exit  exit the program\n\
   help        display this help message\n\
\n\
Help for individual command can be obtained with 'help COMMAND'\
"
        else:
            if args in dir(cmds):
                eval("self." + args + "(\"help\")")
            else:
                print "Unknown command", args

    def echo(self, args):
        if args == "help":
            print "Usage: echo [TEXT]"
            print "   Print text"
            return
        print args        

# Readline configuration
if not os.path.exists(hist_file):
    f=open(hist_file, "w")
    f.write("figlist")
    f.close()
readline.read_history_file(hist_file)

# Parse command line arguments
parser = OptionParser()
parser.add_option("-b", "--batch", dest="fn", help="Execute commands in FILE then exit", metavar="FILE")
parser.add_option("-i", "--interactive", action="store_true", dest="inter", help="Go to interactive mode after executing batch file")
parser.add_option("-q", "--quiet", action="store_true", dest="quiet", help="Do not display startup message")
(options, args) = parser.parse_args()
if options.fn == None:
    f = None
else:
    try:
        f = open(options.fn, 'r')
    except IOError, e:
        print "Unable to access batch file:", e
        f = None
if options.inter == True:
    batch = False
else:
    batch = True

# Prompt
p = "oscopy> "
cmds = Oscopy()

if options.quiet == None:
    print "This is oscopy, a program to view electrical simulation results\n\
Copyright (C) 2009 Arnaud Gardelein.\n\
This is free software, you are invited to redistribute it \n\
under certain conditions.\n\
There is ABSOLUTELY NO WARRANTY; not even for MERCHANTIBILITY or\n\
FITNESS FOR A PARTICULAR PURPOSE."

# Main loop
while True:
    try:
        if f == None:
            inp = raw_input(p)
        else:
            try:
                inp = f.readline().rstrip("\n")
                if inp == "":
                    if batch == True:
                        # Batch mode, exit at the end of script
                        break
                    else:
                        # Interactive mode, continue with command line
                        f = None
                        continue
            except IOError, e:
                print "Script error:", e
                f.close()
                f = None
        # Check if line is a comment
        if inp.lstrip().startswith("#"):
            continue
        # Check if command is assignment
        if inp.find("=") >= 0:
            cmds.math(inp)
            continue

        # Separate command from args
        if inp.find(" ") >= 0:
            st = inp.lstrip().split(' ', 1)    
            cmd = st[0]
            args = st[1]
#            print "cmd:", cmd, "args:", args
        else:
            cmd = inp
            args = ""
            
        # End of program
        if cmd == "exit" or cmd == "quit":
            break

        # Evaluate the command
        if cmd in dir(cmds):
            eval("cmds." + cmd + "(args)")
        else:
            print cmd, "not supported"
        continue

    except EOFError:
        break

#    except AttributeError, e:
#        print "Unknown command:", e.message
#        continue

#    except NameError, e:
#        print "Unknown command", e.message
#        continue

    except SyntaxError, e:
        print "Syntax Error", e.message
        continue

    except Reader.ReadError, e:
        print "Error in read :", e.value

readline.write_history_file(hist_file)

