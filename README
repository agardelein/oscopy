oscopy -- A program to view electrical simulation results

This is oscopy, a kind of oscilloscope in python, to view 2D electrical
simulation results. It is designed to easily new input data file formats
and new types of plots.
Support for basic mathematic with signals is implemented.
This program use matplotlib to plot the data.

oscopy is an example of use of the available functions,
implemented as a simple command line program.

To run the program, just do ./oscopy.

To get any info on available commands, type 'help'.

EXAMPLE:
-------
cd demo
gnetlist -g spice-sdb -s -o demo.net demo.sch
gnucap -b demo.net
cd ..
./oscopy -b demo/demo.oscopy

EXTENDING OSCOPY:
---------------------
New data file format can be added by deriving Reader and
redefining the function readsigs(), which fills the list
of signals self.sigs and return a dict of signals.
During execution, Reader.read() check the validity
of the provided path, and then call readsigs().

New graph mode can be added by deriving Graph and redefining
the function setaxes() which if called by plot(), or eventually 
redefining plot().
NOTE : Figure.setmode() has to be updated when new mode are added !

Vocabular:
A figure is CREATEd or DESTROYed, a graph is ADDed to a figure or DELETEd and a signal is INSERTed or REMOVEd from a graph.

Template for new import format:
---
import Signal
import Readers

class xxxReader(Readers.Reader.Reader):
      def readsigs(self):
          #[...] read the signals data from file and for each signal:
              #create signal:
	      # Reference signal, or X axis
	      sref = Signal("name_ref", self, "unit_ref")
	      sref.setpts([with X data from file as a list or numpy.array])
	      # Signal, or Y axis
	      s = Signal("name_sig", self, "unit_sig")
	      s.setpts([with data from file as a list or numpy.array])
	      # Assign reference to signal
	      s.setref(sref)
          #fill self.slist
	      self.slist.append(s)
	      sigs["name_ref"] = s
          #and return a dict of sigs where key is signal name
	  return sigs

      def detect(self, fn):
          # return True if file fn can be read using this Reader
---
When a importing a signal, first detect is called.
If format is supported, read and subsequent updates will call readsigs

Template for new export format:
---
import Signal
import Writers

class xxxWriter(Writers.Writer.Writer):
      def getfmtname(self):
      ... return a string containing the name of the format

      def fmtcheck(self, sigs):
      ... return True if format can be use to write dict of signals sigs

      def writesigs(self, sigs)
      ... write signals to file
---
When an export command is issued, the format name is compared to the
one provided by the class, and then the signals are passed to the class
to check whether it can write them properly, e.g. if they have the same
abscisse. If eveyrthing is fine, writesigs() is called.
Options passed by user can be found in self.opts.

Template for new graphs:
---
import Graphs
import Signal

class xxxGraph(Graphs.Graph.Graph):
      def plot():
      ... define the plot function, using signals in self.sigs
---

A SCHEME:
---------

   SIGNAL+        + FIGURE +-- GRAPH +-- SIGNAL
   SIGNAL+        |        |         +-- SIGNAL
   SIGNAL+        |        |
	 |        |        +-- GRAPH +-- SIGNAL
         |        |                  +-- SIGNAL
	 |        + FIGURE ...
         |        ...
         |        |
         +- CMDS -+

