oscopy -- An interactive program to view electrical results

This is oscopy, a kind of oscilloscope in python, to view 2D electrical
simulation or measurement results.
It is designed to easily add new input data file formats and new types of plots.

Features highlight:
  * Post-processing: math expressions, fft, diffs
  * View, examine: multiple windows, cursors
  * Data import: gnucap
  * Data export: gnucap, pictures
  * Scripting

Dependencies:
  * Python
  * Numpy
  * Matplotlib

To run the program, just do ./oscopy.

To get any info on available commands, type 'help'.

EXAMPLE:
-------
cd demo
gnetlist -g spice-sdb -s -o demo.net demo.sch
gnucap -b demo.net
cd ..
./oscopy -b demo/demo.oscopy

MATH WITH SIGNALS:
------------------
Support for mathematic with signals is implemented. Supported functions:
trig, sqrt, log... 
Support for (i)fft: fft(v1) + fft(v2) is possible, but please avoid
things like ifft(fft(v1) + fft(v2))
First order diff is supported: diff(v1) or diff(v1, 1)
Access to X axis data is provided through Time and Freq, e.g. sin(Time(vsqu)*1e6)

EXTENDING OSCOPY:
-----------------
New data file format can be added by deriving Reader and
redefining the function readsigs(), which fills the list
of signals self.sigs and return a dict of signals.
During execution, Reader.read() check the validity
of the provided path, and then call readsigs().

New graph mode can be added by deriving Graph and redefining
the function set_axes() which if called by plot(), or eventually 
redefining plot(). See FFTGraph.py for example.
NOTE : Figure.set_mode() has to be updated when new mode are added !

Vocabular:
A figure is CREATEd or DESTROYed, a graph is ADDed to a figure or DELETEd and a signal is INSERTed or REMOVEd from a graph.

Template for new import format:
---
import Signal
import Readers

class xxxReader(Readers.Reader.Reader):
      def readsigs(self):
          #[...] read the signals data from file and for each signal:
              #create signal:
	      # Reference signal, or X axis
	      sref = Signal("name_ref", self, "unit_ref")
	      sref.set_pts([with X data from file as a list or numpy.array])
	      # Signal, or Y axis
	      s = Signal("name_sig", self, "unit_sig")
	      s.set_pts([with data from file as a list or numpy.array])
	      # Assign reference to signal
	      s.set_ref(sref)
          #fill self.slist
	      self.slist.append(s)
	      sigs["name_ref"] = s
          #and return a dict of sigs where key is signal name
	  return sigs

      def detect(self, fn):
          # return True if file fn can be read using this Reader
---
When a importing a signal, first detect is called.
If format is supported, read() and subsequent update() will call readsigs()

Template for new export format:
---
import Signal
import Writers

class xxxWriter(Writers.Writer.Writer):
      def getfmtname(self):
      ... return a string containing the name of the format

      def fmtcheck(self, sigs):
      ... return True if format can be use to write dict of signals sigs

      def writesigs(self, sigs)
      ... write signals to file
---
When an export command is issued, the format name is compared to the
one provided by the class, and then the signals are passed to the class
to check whether it can write them properly, e.g. if they have the same
abscisse. If eveyrthing is fine, writesigs() is called.
Options passed by user can be found in self.opts.

Template for new graphs:
---
import Graphs
import Signal

class xxxGraph(Graphs.Graph.Graph):
      def plot():
      ... define the plot function, using signals in self.sigs
---

A SCHEME:
---------

   READER -- SIGNAL+        + FIGURE +-- GRAPH +-- SIGNAL
          \- SIGNAL+        |        |         +-- SIGNAL
   READER -- SIGNAL+        |        |
                   |        |        +-- GRAPH +-- SIGNAL
                   |        |                  +-- SIGNAL
                   |        + FIGURE ...
                   |        ...
                   |        |
                   +- CMDS -+

